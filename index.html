<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bigger Maze - 50x50 Example</title>
  <style>
    body { margin:0; background:#333; display:flex; flex-direction:column; align-items:center; }
    canvas { background:#000; border:1px solid #444; display:block; margin:10px auto; }
    .controls { display:flex; gap:0.5rem; margin-bottom:1rem; }
    .controls button {
      width:50px; height:50px; font-size:1.5rem; border-radius:8px; border:1px solid #444;
      background:#666; color:#fff; cursor:pointer;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="640" height="480"></canvas>
<div class="controls">
  <button id="btnUp">↑</button>
  <button id="btnLeft">←</button>
  <button id="btnRight">→</button>
  <button id="btnDown">↓</button>
</div>

<script>
//************************************************************
// 1. Generate a 50x50 random maze (0=floor,1=wall).
//    Could scale to 100x100 for 4x the dimension of the 25x25.
//************************************************************
const ROWS = 50;
const COLS = 50;

// Probability that a cell is a wall
const WALL_CHANCE = 0.25;

function createRandomMaze(rows, cols) {
  const newMaze = [];
  for (let r=0; r<rows; r++) {
    newMaze[r] = [];
    for (let c=0; c<cols; c++) {
      // Make the outer boundary walls
      if (r === 0 || r === rows-1 || c === 0 || c === cols-1) {
        newMaze[r][c] = 1;
      } else {
        // Random interior
        newMaze[r][c] = Math.random() < WALL_CHANCE ? 1 : 0;
      }
    }
  }
  return newMaze;
}

// Create the bigger maze
const maze = createRandomMaze(ROWS, COLS);

// Ensure top-left area is open so the player can spawn
maze[1][1] = 0; // floor
// Ensure bottom-right area is open so the enemy can spawn
maze[ROWS-2][COLS-2] = 0;

// Tile size (still 32px)
const TILE_SIZE = 32;

// Canvas
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Player
const player = {
  x: TILE_SIZE * 1,
  y: TILE_SIZE * 1,
  speed: 3
};
// Enemy
const enemy = {
  x: TILE_SIZE * (COLS - 2),
  y: TILE_SIZE * (ROWS - 2),
  speed: 2
};

let keys = {};
const canvasCenterX = canvas.width / 2;
const canvasCenterY = canvas.height / 2;

//************************************************************
// 2. BFS Pathfinding
//************************************************************
function bfsPath(sr, sc, tr, tc, grid) {
  if (sr === tr && sc === tc) return [{row: sr, col: sc}];
  if (!grid[tr] || grid[tr][tc] !== 0) return null;

  const visited = new Set();
  const queue = [];
  queue.push({ row: sr, col: sc, path: [{row: sr, col: sc}] });
  visited.add(`${sr},${sc}`);

  while (queue.length > 0) {
    const { row, col, path } = queue.shift();
    const neighbors = [
      { r: row-1, c: col },
      { r: row+1, c: col },
      { r: row, c: col-1 },
      { r: row, c: col+1 },
    ];
    for (let n of neighbors) {
      if (
        n.r >= 0 && n.r < ROWS &&
        n.c >= 0 && n.c < COLS &&
        grid[n.r][n.c] === 0 &&
        !visited.has(`${n.r},${n.c}`)
      ) {
        const newPath = [...path, { row: n.r, col: n.c }];
        if (n.r === tr && n.c === tc) {
          return newPath;
        }
        queue.push({ row: n.r, col: n.c, path: newPath });
        visited.add(`${n.r},${n.c}`);
      }
    }
  }
  return null;
}

//************************************************************
// 3. Update Player & Enemy
//************************************************************
function updatePlayer() {
  let moveX = 0, moveY = 0;
  if (keys.ArrowUp) moveY = -player.speed;
  if (keys.ArrowDown) moveY =  player.speed;
  if (keys.ArrowLeft) moveX = -player.speed;
  if (keys.ArrowRight) moveX =  player.speed;

  const newX = player.x + moveX;
  const newY = player.y + moveY;
  const tileCol = Math.floor(newX / TILE_SIZE);
  const tileRow = Math.floor(newY / TILE_SIZE);
  if (maze[tileRow] && maze[tileRow][tileCol] === 0) {
    player.x = newX;
    player.y = newY;
  }
}

function updateEnemy() {
  const eCol = Math.floor(enemy.x / TILE_SIZE);
  const eRow = Math.floor(enemy.y / TILE_SIZE);
  const pCol = Math.floor(player.x / TILE_SIZE);
  const pRow = Math.floor(player.y / TILE_SIZE);

  const path = bfsPath(eRow, eCol, pRow, pCol, maze);
  if (!path || path.length < 2) return;
  const nextStep = path[1];
  const targetX = nextStep.col * TILE_SIZE;
  const targetY = nextStep.row * TILE_SIZE;

  const dx = targetX - enemy.x;
  const dy = targetY - enemy.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist > enemy.speed) {
    enemy.x += (dx / dist) * enemy.speed;
    enemy.y += (dy / dist) * enemy.speed;
  } else {
    enemy.x = targetX;
    enemy.y = targetY;
  }
}

//************************************************************
// 4. Draw Maze
//************************************************************
function drawMaze() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const offsetX = canvasCenterX - player.x;
  const offsetY = canvasCenterY - player.y;

  for (let row=0; row<ROWS; row++) {
    for (let col=0; col<COLS; col++) {
      const tileX = col * TILE_SIZE;
      const tileY = row * TILE_SIZE;
      const screenX = tileX + offsetX;
      const screenY = tileY + offsetY;
      if (maze[row][col] === 1) {
        ctx.fillStyle = "darkgray";
      } else {
        ctx.fillStyle = "black";
      }
      ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
    }
  }

  // Player
  const pScreenX = player.x + offsetX;
  const pScreenY = player.y + offsetY;
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(pScreenX, pScreenY, 8, 0, Math.PI*2);
  ctx.fill();

  // Enemy
  const eScreenX = enemy.x + offsetX;
  const eScreenY = enemy.y + offsetY;
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(eScreenX, eScreenY, 8, 0, Math.PI*2);
  ctx.fill();
}

//************************************************************
// 5. Main Loop
//************************************************************
function gameLoop() {
  updatePlayer();
  updateEnemy();
  drawMaze();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

//************************************************************
// 6. Controls
//************************************************************
window.addEventListener("keydown", (e) => {
  keys[e.key] = true;
});
window.addEventListener("keyup", (e) => {
  keys[e.key] = false;
});

// On-screen arrow buttons
["btnUp","btnDown","btnLeft","btnRight"].forEach(id => {
  const btn = document.getElementById(id);
  btn.addEventListener("mousedown", () => {
    if (id === "btnUp") keys.ArrowUp = true;
    if (id === "btnDown") keys.ArrowDown = true;
    if (id === "btnLeft") keys.ArrowLeft = true;
    if (id === "btnRight") keys.ArrowRight = true;
  });
  btn.addEventListener("mouseup", () => {
    if (id === "btnUp") keys.ArrowUp = false;
    if (id === "btnDown") keys.ArrowDown = false;
    if (id === "btnLeft") keys.ArrowLeft = false;
    if (id === "btnRight") keys.ArrowRight = false;
  });
  btn.addEventListener("touchstart", (e) => {
    e.preventDefault();
    if (id === "btnUp") keys.ArrowUp = true;
    if (id === "btnDown") keys.ArrowDown = true;
    if (id === "btnLeft") keys.ArrowLeft = true;
    if (id === "btnRight") keys.ArrowRight = true;
  });
  btn.addEventListener("touchend", (e) => {
    e.preventDefault();
    if (id === "btnUp") keys.ArrowUp = false;
    if (id === "btnDown") keys.ArrowDown = false;
    if (id === "btnLeft") keys.ArrowLeft = false;
    if (id === "btnRight") keys.ArrowRight = false;
  });
});
</script>
</body>
</html>
